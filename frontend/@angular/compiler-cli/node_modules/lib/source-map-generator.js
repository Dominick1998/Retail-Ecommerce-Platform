/* -*- Mode: js; js-indent-level: 2; -*- */
/* vim: set ts=2 sw=2 et tw=80: */
/* Copyright (c) 2009-2019, Mozilla Foundation and contributors */
/* Licensed under the BSD license. See LICENSE file in the project root. */

const base64VLQ = require("./base64-vlq");
const util = require("./util");
const ArraySet = require("./array-set").ArraySet;
const MappingList = require("./mapping-list").MappingList;

/**
 * A SourceMapGenerator instance is used to build a source map incrementally.
 */
class SourceMapGenerator {
  constructor(args) {
    if (!args) {
      args = {};
    }
    this._file = util.getArg(args, "file", null);
    this._sourceRoot = util.getArg(args, "sourceRoot", null);
    this._skipValidation = util.getArg(args, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  /**
   * Add a single mapping from original source line and column to the generated
   * source line and column.
   */
  addMapping(mapping) {
    let generated = mapping.generated;
    let original = mapping.original || null;
    let source = mapping.source || null;
    let name = mapping.name || null;

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null && !this._sources.has(source)) {
      this._sources.add(source);
    }

    if (name != null && !this._names.has(name)) {
      this._names.add(name);
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original ? original.line : null,
      originalColumn: original ? original.column : null,
      source: source,
      name: name
    });
  }

  /**
   * Sets the source content for a given source file.
   */
  setSourceContent(source, sourceContent) {
    let sourceKey = this._sources.indexOf(source);
    if (sourceKey >= 0) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[source] = sourceContent;
    }
  }

  /**
   * Applies a SourceMap for a source file to the current SourceMap.
   */
  applySourceMap(sourceMapConsumer, sourceFile, sourceMapPath) {
    let sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }

    let newSources = new ArraySet();
    let newNames = new ArraySet();

    sourceMapConsumer.eachMapping((mapping) => {
      let newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        let source = mapping.source;
        if (sourceMapPath != null) {
          source = util.join(sourceMapPath, source);
        }
        newSources.add(source);
        newMapping.source = source;
      }

      if (mapping.originalLine != null) {
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
      }

      if (mapping.name != null) {
        newNames.add(mapping.name);
        newMapping.name = mapping.name;
      }

      this.addMapping(newMapping);
    });

    this._sources = newSources;
    this._names = newNames;
  }

  /**
   * Serializes the source map generator to a JSON string.
   */
  toJSON() {
    let map = {
      version: 3,
      file: this._file,
      sources: Array.from(this._sources),
      names: Array.from(this._names),
      mappings: this._serializeMappings()
    };

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources);
    }

    return map;
  }

  /**
   * Returns the mappings as a VLQ-encoded string.
   */
  _serializeMappings() {
    let previousGeneratedLine = 1;
    let previousGeneratedColumn = 0;
    let previousOriginalLine = 0;
    let previousOriginalColumn = 0;
    let previousSource = 0;
    let previousName = 0;
    let result = "";
    let mappings = this._mappings.toArray();

    for (let i = 0; i < mappings.length; i++) {
      let mapping = mappings[i];
      let next = "";

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }
        next += ",";
      }

      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        next += base64VLQ.encode(this._sources.indexOf(mapping.source) - previousSource);
        previousSource = this._sources.indexOf(mapping.source);

        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          next += base64VLQ.encode(this._names.indexOf(mapping.name) - previousName);
          previousName = this._names.indexOf(mapping.name);
        }
      }

      result += next;
    }

    return result;
  }
}

module.exports = SourceMapGenerator;
