/* -*- Mode: js; js-indent-level: 2; -*- */
/* vim: set ts=2 sw=2 et tw=80: */
/* Copyright (c) 2009-2019, Mozilla Foundation and contributors */
/* Licensed under the BSD license. See LICENSE file in the project root. */

const util = require("./util");
const binarySearch = require("./binary-search");
const ArraySet = require("./array-set").ArraySet;
const base64VLQ = require("./base64-vlq");
const quickSort = require("./quick-sort");

function SourceMapConsumer(aSourceMap) {
  if (typeof aSourceMap === "string") {
    aSourceMap = JSON.parse(aSourceMap);
  }

  let version = util.getArg(aSourceMap, "version");
  let sources = util.getArg(aSourceMap, "sources");
  let names = util.getArg(aSourceMap, "names", []);
  let sourceRoot = util.getArg(aSourceMap, "sourceRoot", null);
  let sourcesContent = util.getArg(aSourceMap, "sourcesContent", null);
  let mappings = util.getArg(aSourceMap, "mappings");
  let file = util.getArg(aSourceMap, "file", null);

  this._version = version;
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._sourceRoot = sourceRoot;
  this._sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._file = file;
  
  sources.forEach((source) => {
    this._sources.add(source);
  });

  names.forEach((name) => {
    this._names.add(name);
  });

  this._generatedMappings = [];
  this._originalMappings = [];
  this._parseMappings(mappings, sourceRoot);
}

/**
 * Parse the mappings string into an array of mappings.
 */
SourceMapConsumer.prototype._parseMappings = function(mappings, sourceRoot) {
  let generatedLine = 1;
  let generatedColumn = 0;
  let originalLine = 0;
  let originalColumn = 0;
  let source = 0;
  let name = 0;

  let mappingSeparator = /^[,;]/;
  let str = mappings;
  let mapping, temp;

  while (str.length > 0) {
    if (mappingSeparator.test(str)) {
      if (str[0] === ";") {
        generatedLine++;
        generatedColumn = 0;
      }
      str = str.slice(1);
      continue;
    }

    mapping = {};
    mapping.generatedLine = generatedLine;

    // Generated column
    temp = base64VLQ.decode(str);
    mapping.generatedColumn = generatedColumn + temp.value;
    generatedColumn = mapping.generatedColumn;
    str = temp.rest;

    if (str.length > 0 && !mappingSeparator.test(str)) {
      // Source
      temp = base64VLQ.decode(str);
      source += temp.value;
      mapping.source = this._sources.at(source);
      str = temp.rest;

      if (str.length > 0 && !mappingSeparator.test(str)) {
        // Original line
        temp = base64VLQ.decode(str);
        originalLine = temp.value + 1;
        mapping.originalLine = originalLine;
        str = temp.rest;

        if (str.length > 0 && !mappingSeparator.test(str)) {
          // Original column
          temp = base64VLQ.decode(str);
          originalColumn = temp.value;
          mapping.originalColumn = originalColumn;
          str = temp.rest;

          if (str.length > 0 && !mappingSeparator.test(str)) {
            // Name
            temp = base64VLQ.decode(str);
            name += temp.value;
            mapping.name = this._names.at(name);
            str = temp.rest;
          }
        }
      }
    }

    this._generatedMappings.push(mapping);
  }
};

/**
 * Returns the original source position for a given generated line and column.
 */
SourceMapConsumer.prototype.originalPositionFor = function(line, column) {
  let mapping = binarySearch.search(this._generatedMappings, { 
    generatedLine: line, 
    generatedColumn: column 
  }, function(a, b) {
    return a.generatedLine - b.generatedLine || a.generatedColumn - b.generatedColumn;
  });

  if (!mapping) {
    return null;
  }

  return {
    source: mapping.source,
    line: mapping.originalLine,
    column: mapping.originalColumn,
    name: mapping.name
  };
};

module.exports = SourceMapConsumer;
